# RDT-VoI Simulation Configuration
# Units: SI (meters, seconds) + GBP (£)

experiment:
  name: "rdt_sensor_optimization_v1"
  seed: 202501
  output_dir: "runs"

# Numerical tolerances
numerics:
  linear_solver_tol: 1.0e-8
  cholesky_nugget: 1.0e-9
  pcg_max_iter: 1000
  logdet_method: "cholesky"  # cholesky | hutchpp

# Geometry configuration
geometry:
  mode: "grid2d"  # grid2d | polyline1d | graph
  # Grid2D parameters
  nx: 40
  ny: 40
  h: 5.0  # meters, grid spacing
  # Graph parameters (if mode="graph")
  # adjacency_file: "road_network.adj"

# GMRF Prior (SPDE-Matérn α=2)
prior:
  # Matérn parameters
  nu: 1.0          # smoothness
  kappa: 0.08      # 1/correlation_range (1/m)
  sigma2: 0.04     # marginal variance (IRI units: (m/km)^2)

  # Discrete precision Q = alpha*L + beta*I
  alpha: 2         # SPDE operator power
  beta: 1.0e-6     # nugget for SPD guarantee

  # Mean field
  mu_prior_mean: 1.5   # baseline IRI (m/km)
  mu_prior_std: 0.0    # 0 = deterministic mean

# Sensor types (from parameter handbook)
sensors:
  types:
    - name: "inertial_profiler"
      noise_std: 0.1      # IRI std (m/km), ~2.5 in/mi
      cost_gbp: 10000.0   # £ per deployment
      footprint: "point"

    - name: "photogrammetry"
      noise_std: 0.25     # conditional: clear day
      cost_gbp: 5000.0
      footprint: "avg3x3"

    - name: "smartphone"
      noise_std: 0.5      # high noise, r≈0.9 → 20% unexplained var
      cost_gbp: 500.0
      footprint: "avg5x5"

  # Candidate pool generation
  pool_strategy: "grid_subsample"  # grid_subsample | random | importance
  pool_fraction: 0.25              # 25% of state locations
  type_mix: [0.4, 0.4, 0.2]        # proportion of each type

# Decision model (threshold-based maintenance)
decision:
  tau_iri: 2.7        # IRI threshold (m/km), ~170 in/mi
  L_TP_gbp: 5000.0    # True Positive: planned maintenance
  L_FP_gbp: 8000.0    # False Positive: unnecessary work + user delay
  L_FN_gbp: 40000.0   # False Negative: deferred cost escalation (5-10x)
  L_TN_gbp: 0.0

# Sensor selection algorithms
selection:
  methods: ["greedy_mi", "greedy_aopt", "uniform", "random"]
  budgets: [5, 10, 20, 40, 60, 80]

  greedy_mi:
    lazy: true
    cost_normalized: true
    warmstart_enum: false  # enumerate small subsets for guarantee

  greedy_aopt:
    lazy: true
    trace_estimator: "hutchpp"  # hutchpp | probing | exact
    hutchpp_probes: 20

# EVI approximation (computationally expensive, use sparingly)
evi:
  compute_for: ["greedy_mi"]  # only for best method
  method: "unscented"  # monte_carlo | unscented
  monte_carlo_samples: 500
  unscented_alpha: 1.0
  unscented_beta: 2.0
  unscented_kappa: 0.0

# Spatial Cross-Validation
cv:
  scheme: "spatial_block"  # spatial_block | lolo
  k_folds: 5
  buffer_width_multiplier: 1.5  # × correlation_length

  # Spatial block parameters
  block_strategy: "kmeans"  # kmeans | grid | hexagon
  ensure_connected: true

  # LOLO parameters (if scheme="lolo")
  # location_clusters: ["city_A", "city_B", "city_C"]

# Uncertainty quantification
uq:
  bootstrap_method: "spatial_block"  # spatial_block | residual
  bootstrap_samples: 1000
  confidence_level: 0.95

  # Calibration metrics
  coverage_percentile: 90
  compute_crps: false

# Diagnostics
diagnostics:
  morans_i:
    weight_type: "adjacency"  # adjacency | inverse_distance
    permutations: 999

  calibration:
    compute_coverage: true
    compute_msse: true

# Visualization
plots:
  save_formats: ["png", "pdf"]
  dpi: 300
  style: "seaborn-v0_8-paper"

  budget_curves:
    metrics: ["expected_loss", "rmse", "mae"]
    show_ci: true

  performance_profile:
    tau_max: 3.0

  critical_difference:
    test: "nemenyi"  # nemenyi | wilcoxon_holm
    alpha: 0.05

# Acceptance criteria (for automated validation)
acceptance:
  m1_grid_size: 1600  # 40×40
  m1_budgets: [10, 20, 40]
  m1_check_monotonic: true
  m1_check_diminishing: true

  m2_min_improvement_vs_random: 0.15  # 15% loss reduction
  m2_confidence_level: 0.95

  m3_small_instance_n: 200
  m3_small_instance_k: 8
  m3_max_suboptimality: 1.58  # 1/(1-1/e)

  m4_morans_alpha: 0.05
  m4_coverage_tolerance: 0.05  # ±5% of nominal 90%
  m4_msse_tolerance: 0.2       # MSSE ∈ [0.8, 1.2]

# Logging
logging:
  level: "INFO"  # DEBUG | INFO | WARNING | ERROR
  console: true
  file: true
  jsonl_metrics: true